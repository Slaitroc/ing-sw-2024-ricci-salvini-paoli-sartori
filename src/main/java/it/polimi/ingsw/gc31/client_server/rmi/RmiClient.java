package it.polimi.ingsw.gc31.client_server.rmi;

import it.polimi.ingsw.gc31.client_server.Token;
import it.polimi.ingsw.gc31.client_server.interfaces.*;
import it.polimi.ingsw.gc31.client_server.queue.clientQueue.ClientQueueObject;
import it.polimi.ingsw.gc31.client_server.queue.serverQueue.*;
import it.polimi.ingsw.gc31.exceptions.NoGamesException;
import it.polimi.ingsw.gc31.utility.DV;
import it.polimi.ingsw.gc31.utility.FileUtility;
import it.polimi.ingsw.gc31.view.UI;

import java.awt.*;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * The RmiClient class represents a remote client that interacts with a virtual
 * server using RMI (Remote Method Invocation) protocol.
 * It implements the {@link VirtualClient} interface to allow the rmi server to call methods on the client via the RMI communication protocol.
 * It implements also the {@link ClientCommands} interface which defines the methods that can be called from the tui on the client-side rmiClient.
 */
public class RmiClient extends UnicastRemoteObject implements VirtualClient, ClientCommands {

    /**
     * This private variable represents an instance of the interface IController.
     * It is used to send commands from the client to the {@link IController} on the server using the rmi communication protocol.
     */
    private IController controller;

    /**
     * This private variable represents an instance of the interface VirtualServer.
     * It is used to send commands from the client to the {@link RmiServer} on the server using the rmi communication protocol.
     */
    private final VirtualServer server;

    /**
     * This private variable represents an instance of the interface IGameController.
     * It is used to send commands from the client to the {@link it.polimi.ingsw.gc31.controller.GameController} on the server using the rmi communication protocol.
     */
    private IGameController gameController;

    /**
     * The idGame of the current game the client is joined.
     */
    private Integer idGame;

    /**
     * The username with which the player is logged into the game.
     */
    private String username;

    /**
     * The ui that allows the player to interact with the game.
     */
    private UI ui;

    /**
     * Queue where the {@link ClientQueueObject} sent by the server are added
     */
    private final LinkedBlockingQueue<ClientQueueObject> callsList;

    /**
     * Used to determine the connection with the server.
     */
    public Token token;

    /**
     * Timer used to send the heartBeat.
     */
    private final Timer timer;

    /**
     * Represents the player is ready to play or not.
     * It is set to false by default.
     */
    private boolean ready = false;



    /**
     * Creates a new RmiClient object.
     * The first connection with the server occurs and the reference to the virtualServer is saved in the server variable
     * e notifies the server of the first connection.
     * The tempToken generated by the server is saved which allows the server to identify this client until the username is set.
     * The executor thread is started.
     *
     * @param ipaddress the IP address of the server to connect to
     * @throws RemoteException if a remote error occurs
     * @throws NotBoundException if the specified name is not currently bound in the registry
     */
    public RmiClient(String ipaddress) throws RemoteException, NotBoundException {
        this.server = (VirtualServer) LocateRegistry.getRegistry(ipaddress, DV.RMI_PORT)
                .lookup("VirtualServer");
        this.server.RMIserverWrite("New connection detected from ip: " + server.getClientIP());
        this.token = new Token();
        token.setTempToken(this.server.generateToken(this));
        this.username = DV.DEFAULT_USERNAME;
        this.controller = null;
        this.callsList = new LinkedBlockingQueue<>();
        timer = new Timer(true);
        new Thread(this::executor).start();
    }



    /**
     * Add a ClientQueueObject to the callsList and notify any waiting threads.
     *
     * @param obj the ClientQueueObject to be added to the callsList
     */
    private void addQueueObj(ClientQueueObject obj) {
        synchronized (callsList) {
            callsList.add(obj);
            callsList.notify();
        }
    }


    /**
     * Thread that takes an object from the callList and executes it.
     */
    private void executor() {
        new Thread(() -> {
            while (true) {
                ClientQueueObject action;
                synchronized (callsList) {
                    while (callsList.isEmpty()) {
                        try {
                            callsList.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    action = callsList.poll();
                }
                if (action != null) {
                    action.execute(ui);

                }
            }
        }).start();
    }

    // CLIENT COMMANDS

    /**
     * Sets the ui that will communicate with the client.
     *
     * @param ui the UI object to set
     */
    public void setUI(UI ui) {
        this.ui = ui;
    }

    /**
     * Method of the {@link ClientCommands} that sends the object to the server for connection with the client.
     * The parameters are the username, tempToken and token.
     *
     * @param username the username to set.
     * @throws RemoteException if a remote error occurs
     */
    @Override
    public void setUsernameCall(String username) throws RemoteException {
        server.sendCommand(new ConnectObj(username, this.token.getTempToken(), this.token.getToken()));
    }

    /**
     * Method of the {@link ClientCommands} that sets the username of the client.
     *
     * @param username the username to set
     */
    @Override
    public void setUsername(String username) {
        this.username = username;
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the controller of the type {@link CreateGameObj}
     * that tells the server to create a new game with a specified maximum number of players.
     *
     * @param maxNumberPlayer the maximum number of players for the game
     * @throws RemoteException if a remote error occurs
     */
    @Override
    public void createGame(int maxNumberPlayer) throws RemoteException {
        controller.sendCommand(new CreateGameObj(username, maxNumberPlayer));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the controller of the type {@link JoinGameObj} that ask the server to join the game with the specified game id.
     *
     * @param idGame the ID of the game to join
     * @throws RemoteException if a remote error occurs
     */
    @Override
    public void joinGame(int idGame) throws RemoteException {
        controller.sendCommand(new JoinGameObj(username, idGame));
    }

    /**
     * Method of the {@link ClientCommands} that sends a command to quit the game.
     *
     * @throws RemoteException if a remote error occurs during the method call
     */
    @Override
    public void quitGame() throws RemoteException {
        gameController.sendCommand(new QuitGameObj(username));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the controller of the type {@link GetGameListObj}
     * that ask the server send back the list of the games presents on the server.
     *
     * @throws RemoteException if a remote error occurs
     * @throws NoGamesException if there are no games available
     */
    @Override
    public void getGameList() throws RemoteException, NoGamesException {
        controller.sendCommand(new GetGameListObj(token.getToken()));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link ReadyStatusObj}
     * that tells the server if the player is ready to play or not.
     *
     * @param ready   the ready status to set
     * @throws RemoteException if there is an error in the remote communication
     */
    @Override
    public void setReady(boolean ready) throws RemoteException {
        gameController.sendCommand(new ReadyStatusObj(ready, username));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link DrawGoldObj}
     * that tells the server the player draws a card from the deck.
     *
     * @param index the index of the card the player wants to draw.
     *              0 if the player draws the card on the top od the deck.
     *              1 if the player draws the first flipped card.
     *              2 if the player draws the second flipped card.
     *              If a value other than these three an object of the type {@link it.polimi.ingsw.gc31.client_server.queue.clientQueue.ShowInvalidActionObj} is sent by the server.
     * @throws RemoteException if there is an error in the remote communication
     */
    @Override
    public void drawGold(int index) throws RemoteException {
        gameController.sendCommand(new DrawGoldObj(username, index));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link DrawResObj}
     * that tells the server the player draws a card from the deck.
     *
     * @param index the index of the card the player wants to draw.
     *              0 if the player draws the card on the top od the deck.
     *              1 if the player draws the first flipped card.
     *              2 if the player draws the second flipped card.
     *              If a value other than these three an object of the type {@link it.polimi.ingsw.gc31.client_server.queue.clientQueue.ShowInvalidActionObj} is sent by the server.
     * @throws RemoteException if there is an error in the remote communication
     */
    @Override
    public void drawResource(int index) throws RemoteException {
        gameController.sendCommand(new DrawResObj(username, index));
        // gameController.drawResource(username);
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link ChooseSecretObjectiveObj}
     * that tells the server the player choose the first
     * secret objective card.
     *
     * @throws RemoteException if a remote error occurs
     */
    @Override
    public void chooseSecretObjective1() throws RemoteException {
        gameController.sendCommand(new ChooseSecretObjectiveObj(username, 0));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link ChooseSecretObjectiveObj}
     * that tells the server the player choose the second
     * secret objective card.
     *
     * @throws RemoteException if a remote error occurs
     */
    @Override
    public void chooseSecretObjective2() throws RemoteException {
        gameController.sendCommand(new ChooseSecretObjectiveObj(username, 1));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link PlayStarterObj}
     * that tells the server the player play the starter card.
     *
     * @throws RemoteException if there is an error in the remote communication
     */
    @Override
    public void playStarter() throws RemoteException {
        gameController.sendCommand(new PlayStarterObj(username));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link PlayObj}
     * that tells the server the player wants to play the selected card
     * in the {@link it.polimi.ingsw.gc31.model.player.PlayArea}.
     *
     * @param point The coordinates of the point where the player wants to play the selected card.
     * @throws RemoteException If there is an error in the remote communication
     */

    @Override
    public void play(Point point) throws RemoteException {
        gameController.sendCommand(new PlayObj(username, point.x, point.y));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link SelectCardObj}
     * that tells the server the player wants to select a card
     * contained in his hand.
     *
     * @param index the index of the card to be selected.
     *              The accepted indexes are 0,1,2, other indexes cause the server to send an object of the type
     *              {@link it.polimi.ingsw.gc31.client_server.queue.clientQueue.ShowInvalidActionObj} is sent by the server.
     * @throws RemoteException if there is an error in the remote communication
     */
    @Override
    public void selectCard(int index) throws RemoteException {
        gameController.sendCommand(new SelectCardObj(username, index));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link FlipCardObj}
     * that tells the server the player wants to change the side of the selected card of the hand.
     *
     * @throws RemoteException if a remote exception occurs during the method call.
     */
    @Override
    public void changeSide() throws RemoteException {
        gameController.sendCommand(new FlipCardObj(username));
    }

    /**
     * Method of the {@link ClientCommands} that send an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link FlipStarterCardObj}
     * that tells the server the player wants to change the side of the starter card.
     *
     * @throws RemoteException if a remote exception occurs during the method call.
     */
    @Override
    public void changeStarterSide() throws RemoteException {
        gameController.sendCommand(new FlipStarterCardObj(username));
    }

    /**
     * Method of the {@link ClientCommands} that returns the ID of the game the player is currently playing.
     *
     * @return the ID of the game.
     */
    @Override
    public int getGameID() {
        return idGame;
    }

    /**
     * Method of the {@link ClientCommands} that returns the username associated with this user.
     *
     * @return the username of the user
     */
    @Override
    public String getUsername() {
        return username;
    }

    /**
     * Method of the {@link ClientCommands} that sends an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link ChatMessage} that
     * write a message in the chat of the game.
     *
     * @param username the username of the user sending the message
     * @param message the message content
     * @throws RemoteException if there is a problem with the remote communication
     */
    @Override
    public void sendChatMessage(String username, String message) throws RemoteException {
        gameController.sendCommand(new ChatMessage(username, message));
    }

    /**
     * Method of the {@link ClientCommands} that sends an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link ChatMessage} that
     * write a private message in the chat of the game.
     *
     * @param fromUsername the username of the user sending the message
     * @param toUsername the username of the user who receive the message
     * @param message the message content
     * @throws RemoteException if there is a problem with the remote communication
     */
    @Override
    public void sendChatMessage(String fromUsername, String toUsername, String message) throws RemoteException {
        gameController.sendCommand(new ChatMessage(fromUsername, toUsername, message));
    }

    /**
     * Method of the {@link ClientCommands} that sets the {@code token} for authentication.
     * If the token to be set is permanent write the token in a file.
     * If the token is temporary then save it in a file.
     * It is saved in a file to allow the player to reconnect to the game he was playing in case of disconnection
     *
     * @param token the token value to be set
     * @param temporary if true, sets temporary token; otherwise, sets permanent token
     */
    @Override //
    public void setToken(int token, boolean temporary) {
        if (!temporary) {
            this.token.setToken(token);
            this.token.setTempToken(token);
            if (this.token.rewriteTokenFile())
                ui.show_GenericClientResponse("File previously deleted");
            ui.show_GenericClientResponse("Token correctly saved to the path: ");
            ui.show_GenericClientResponse(FileUtility.getCodexTokenFilePath().toString());
        } else {
            this.token.setTempToken(token);
        }
    }

    /**
     * Method of the {@link ClientCommands} that return the {@code token}.
     *
     * @return The token associated with the current instance.
     */
    @Override
    public Token getToken() {
        return this.token;
    }

    /**
     * Method of the {@link ClientCommands} that sends an object to the {@link it.polimi.ingsw.gc31.controller.GameController} of the type {@link ReconnectObj} that
     * tells the server if the player wants to rejoin the game which he previously disconnected from.
     *
     * @param reconnect true to rejoin to the game which the player previously disconnected from , false to not rejoin.
     * @throws RemoteException if there is a communication error with the server
     */
    @Override
    public void reconnect(boolean reconnect) throws RemoteException {
        controller.sendCommand(new ReconnectObj(reconnect, token.getTempToken(), token.getToken()));
    }

    // VIRTUAL CLIENT

    /**
     * Method of the {@link VirtualClient} that return the ready status of the player.
     *
     * @return {@code true} if the object is ready, {@code false} otherwise.
     */
    @Override
    public boolean isReady() {
        return ready;
    }

    /**
     * Method of the {@link VirtualClient} that sets the game ID for this object.
     *
     * @param i the game ID to set
     * @throws RemoteException if a remote error occurs during the method call
     */
    @Override
    public void setGameID(int i) throws RemoteException {
        this.idGame = i;
    }

    /**
     * Method of the {@link VirtualClient} that is called by the server to send an object of type {@link ClientQueueObject}.
     *
     * @param obj the ClientQueueObject representing the command to be executed
     * @throws RemoteException if there is an error in the remote communication
     */
    @Override
    public void sendCommand(ClientQueueObject obj) throws RemoteException {
        addQueueObj(obj);
    }

    /**
     * Method of the {@link VirtualClient} that is called by the server to set {@code controller} with
     * the reference to the controller presents on the server.
     *
     * @param controller The controller to be set.
     * @throws RemoteException If a remote error occurs.
     */
    @Override
    public void setController(IController controller) throws RemoteException {
        this.controller = controller;
        startHeartBeat();
    }

    /**
     * Method of the {@link VirtualClient} that is called by the server to set {@code gameController} with
     * the reference to the {@code gameController} presents on the server.
     *
     * @param gameController The controller to be set.
     * @throws RemoteException If a remote error occurs.
     */
    @Override
    public void setGameController(IGameController gameController) throws RemoteException {
        this.gameController = gameController;
    }

    // Risorse per heartbeat
    /**
     * This method sends to the controller the heart beat associated with the
     * VirtualClient that is sending it
     *
     * @throws RemoteException if an error occurs during the rmi communication
     */
    private void sendHeartBeat() throws RemoteException {
        controller.updateHeartBeat(this);
        // System.out.println("HeartBeat inviato");
    }

    /**
     * This method starts the process that "sends" the heart beat periodically to
     * the server
     * A heart beat is sent immediately on the first execution and every 2 seconds
     * after it
     */
    public void startHeartBeat() {
        long sendTime = (DV.testHB) ? DV.sendTimeTest : DV.sendTime;
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                try {
                    sendHeartBeat();
                } catch (RemoteException e) {
                    throw new RuntimeException(e);
                }
            }
        }, 0, sendTime);
    }

//    @Override
//    public void anotherMatchResponse(Boolean wantsToRematch) throws RemoteException {
//        gameController.sendCommand(new AnotherMatchResponseObj(username, wantsToRematch));
//    }
//
//    @Override
//    public boolean hasToken() {
//        if (token.doesTokenExists())
//            return true;
//        else
//            return false;
//
//    }
//
//    @Override
//    public int readToken() throws NumberFormatException, NoTokenException {
//        return Integer.parseInt(token.getTokenLine());
//    }



}